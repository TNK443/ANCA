# -*- coding: utf-8 -*-
"""10908.ipynb

\title{Resposta do Trabalho 01 | 2.1 - Pesquisa Completa: 10908}
\subtitle{Análise e Complexidade de Algoritmos}
\author{Dornélio Mori Junior}
\affil{PPComp --- Campus Serra, Ifes}
\date{2021-04-06}

Automatically generated by Colaboratory.

Original file is located at
    https://github.com/TNK443/AnCA/blob/main/Trabalho01/10908/10908.ipynb
    https://colab.research.google.com/github/TNK443/AnCA/blob/main/Trabalho01/10908/10908.ipynb
    
"""

def read_input():
    # INPUT
    TCases=[] # T Test Cases

    # The input starts with a line containing a single integer T(<21).
    # Como neste problema o algoritmo não pede para tratar as retrições, 
    # tais restrições não foram tratadas para aumentar a efetividade nos teste do JUDGE.
    T = int(input())

    for t in range(T):
    # This is followed by T test cases.
    # The first line of each of them will contain three integers M, N and Q (<21) separated by a space where M, N denotes the dimension of the grid.
      M,N,Q = 0,0,0
      GRID = [] #Grid(MxN)
      CENT = [] #Center(Q)
      
      auxImput = input().split()
      M = int(auxImput[0])
      N = int(auxImput[1])
      Q = int(auxImput[2])

      # Next follows M lines each containing N characters.
      for m in range(M):
        auxImput = input()
        GRID.append(list(auxImput))
 
      # Finally, there will be Q lines each containing two integers r and c. The value of M and N will be at most 100.
      for q in range(Q):
        r, c = 0,0
        auxImput = input().split()
        r = int(auxImput[0])
        c = int(auxImput[1])
        CENT.append([r,c])
      
      TCases.append([M, N, Q, GRID, CENT])
    return (TCases)

def exec_input(input):
    for t in input:
        M, N, Q = t[0], t[1], t[2]
        print(f"{M} {N} {Q}") ## OUTPUT ##
 
        for q in range(Q):
            r, c = 0,0
            auxOutput = 1
            r = int(t[4][q][0])
            c = int(t[4][q][1])

            if ((r == (M-1)) or (r == 0) or (c == (N-1)) or (c ==0)):
              auxOutput = 1 ## OUTPUT_ ##
            else:
              L = max(M, N)
              C = 1 # CAMADA = 0(CENTRO), quando o quadrado é formado por apenas 1 elemento.
              for l in range(3, L, 2): # l = LARGURA/TAMANDO DE CADA CAMADA.
                  if calcQ(r, c, M, N, t[3], l, C):
                     auxOutput = l ## _OUTPUT ##
                     C+=1 #Vai para a próxima CAMADA.
                  else:
                     break            
            print(auxOutput, end='\n') ## OUTPUT ##
            

def calcQ(i,j,M,N,GRID,l, C):
    # (C)CAMADA = 0(CENTRO), quando o quadrado é formado por apenas 1 elemento. E l=1.
    # (C)CAMADA = 1. Camada depois da CAMADA 0(Centro). O l=3, ou seja, Camada formada com laterais de tamanho 3.
    # (C)CAMADA = x. Camada x depois da Camada0.
    center = GRID[i][j] #Caracter que encontra-se no Centro indicado.
    
    #Testa se as Pontas desta nova Camada(Quadrado) extrapolam as dimensões do GRID.
    if (i+C >= M) or (j+C >= N):return False
    if (i-C < 0) or (j-C < 0):return False

    #Testa se as Pontas desta nova camada(Quadrado) são do mesmo tipo do Centro(Q)
    if (GRID[(i-C)][(j-C)] != center):return False
    if (GRID[(i-C)][(j+C)] != center):return False
    if (GRID[(i+C)][(j+C)] != center):return False
    if (GRID[(i+C)][(j-C)] != center):return False
    
    #Testa o restante do perímetro do quadrado, TESTA DE FORMA DIAGONAL. Em nenhum momento repete-se as células(Grid[i,j]). 
    for k in range(1,l-1):
      if (GRID[(i-C)+k][(j-C)+0] != center): return False
      if (GRID[(i-C)+0][(j-C)+k] != center): return False
      if (GRID[(i+C)-k][(j+C)-0] != center): return False
      if (GRID[(i+C)-0][(j+C)-k] != center): return False
    return True # A CAMADA ESTÁ OK, É FORMADA POR ELEMENTOS IGUAIS AO DO CENTRO.

if __name__ == '__main__':
    try:
      input = read_input()
      exec_input(input)

    except EOFError:
      pass

    finally:
      exit(0)

    exit(0)